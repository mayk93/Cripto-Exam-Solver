// src/utils/multiplicativeElgamal.js
import { modInverse, modPow } from "./rsa";

export function solveMultiplicativeElgamal(p, g, h, c1, c2) {
  let explanation = "";

  explanation += `We are working in the multiplicative ElGamal scheme modulo p = ${p}.\n`;
  explanation += `The group is (ℤ_${p}^×, ·, 1), generated by g = ${g}.\n`;
  explanation += `Alice's public key is h = ${h} and Bob sends the ciphertext (c₁, c₂) = (${c1}, ${c2}).\n\n`;

  explanation += `1) Recover Alice's secret key x from h = gˣ.\n`;
  explanation += `   In general this is the discrete logarithm problem, but here p is small,\n`;
  explanation += `   so we can find x by checking successive powers of g modulo p.\n\n`;

  // Find x such that g^x ≡ h (mod p)
  let current = 1;
  let x = -1;
  const powers = [];

  for (let k = 1; k <= p - 1; k++) {
    current = (current * g) % p;
    powers.push({ k, value: current });
    if (current === (h % p + p) % p) {
      x = k;
      break;
    }
  }

  if (x === -1) {
    throw new Error(`Could not find x such that gˣ ≡ h (mod p). Check inputs.`);
  }

  explanation += `   Powers of g modulo p (up to the point we find h):\n`;
  powers.forEach(({ k, value }) => {
    explanation += `   g^${k} ≡ ${value} (mod ${p})\n`;
    if (value === h % p) {
      explanation += `   ⇒ For k = ${k}, g^${k} ≡ h = ${h} (mod ${p}), so the secret key is x = ${k}.\n`;
    }
  });
  explanation += `\n`;

  // Compute c1^x mod p
  const c1PowX = modPow(c1, x, p);
  explanation += `2) Compute c₁ˣ modulo p.\n`;
  explanation += `   c₁ˣ ≡ ${c1}^${x} mod ${p} = ${c1PowX}.\n\n`;

  // Compute inverse of c1^x
  const inv = modInverse(c1PowX, p);
  explanation += `3) Compute the inverse of c₁ˣ modulo p by the extended Euclidean algorithm.\n`;
  explanation += `   Let a = c₁ˣ = ${c1PowX}. We find a⁻¹ such that a·a⁻¹ ≡ 1 (mod ${p}).\n`;
  explanation += `   The result is a⁻¹ ≡ ${inv} (mod ${p}).\n\n`;

  // Recover m
  let m = (c2 * inv) % p;
  if (m < 0) m += p;

  explanation += `4) Recover the clear message m.\n`;
  explanation += `   m ≡ c₂ · (c₁ˣ)⁻¹ mod p = ${c2} · ${inv} mod ${p} = ${m}.\n\n`;
  explanation += `So the clear message is m = ${m}.`;

  return { m, explanation };
}

// Second version: two-method solution (via x and via y)
export function solveMultiplicativeElgamalTwoMethods(p, g, h, c1, c2) {
  let explanation = "";

  explanation += `We are working in the multiplicative ElGamal scheme modulo p = ${p}.\n`;
  explanation += `The group is (ℤ_${p}^×, ·, 1), generated by g = ${g}.\n`;
  explanation += `Alice's public key is h = ${h}, and the encrypted message is (c₁, c₂) = (${c1}, ${c2}).\n\n`;

  explanation += `1) Compute powers of g modulo p to recover both the secret key x and the temporary key y.\n`;
  explanation += `   We list gⁿ mod p for n = 1, 2, … until we encounter h and c₁ in the table.\n\n`;

  const targetH = ((h % p) + p) % p;
  const targetC1 = ((c1 % p) + p) % p;

  let current = 1;
  let x = null;
  let y = null;

  for (let k = 1; k <= p - 1; k++) {
    current = (current * g) % p;
    let line = `   g^${k} ≡ ${current} (mod ${p})`;

    if (current === targetH) {
      x = k;
      line += `   ⇐ this equals h = ${h}, so x = ${k}.`;
    }
    if (current === targetC1) {
      y = k;
      line += `   ⇐ this equals c₁ = ${c1}, so y = ${k}.`;
    }

    explanation += line + "\n";
  }

  explanation += "\n";

  if (x === null) {
    throw new Error(`Could not find x such that gˣ ≡ h (mod p). Check the inputs.`);
  }
  if (y === null) {
    throw new Error(`Could not find y such that gʸ ≡ c₁ (mod p). Check the inputs.`);
  }

  // ---------- Method 1: use the secret key x ----------
  explanation += `2) First method: use the secret key x.\n`;
  explanation += `   From the table we have x = ${x} with gˣ ≡ h (mod p).\n`;

  const c1PowX = modPow(c1, x, p);
  explanation += `   We compute c₁ˣ modulo p:\n`;
  explanation += `   c₁ˣ ≡ ${c1}^${x} (mod ${p}) = ${c1PowX}.\n`;

  const invC1PowX = modInverse(c1PowX, p);
  explanation += `   Then we compute its inverse (c₁ˣ)⁻¹ modulo p using the extended Euclidean algorithm:\n`;
  explanation += `   (c₁ˣ)⁻¹ ≡ ${invC1PowX} (mod ${p}).\n`;

  let m1 = (c2 * invC1PowX) % p;
  if (m1 < 0) m1 += p;

  explanation += `   Finally we decrypt with this method:\n`;
  explanation += `   m ≡ c₂ · (c₁ˣ)⁻¹ mod p = ${c2} · ${invC1PowX} (mod ${p}) = ${m1}.\n\n`;

  // ---------- Method 2: use the temporary key y ----------
  explanation += `3) Second method: use the temporary key y.\n`;
  explanation += `   From the table we have y = ${y} with gʸ ≡ c₁ (mod p).\n`;

  const hPowY = modPow(h, y, p);
  explanation += `   We compute hʸ modulo p:\n`;
  explanation += `   hʸ ≡ ${h}^${y} (mod ${p}) = ${hPowY}.\n`;

  const invHPowY = modInverse(hPowY, p);
  explanation += `   Then we compute the inverse (hʸ)⁻¹ modulo p:\n`;
  explanation += `   (hʸ)⁻¹ ≡ ${invHPowY} (mod ${p}).\n`;

  let m2 = (c2 * invHPowY) % p;
  if (m2 < 0) m2 += p;

  explanation += `   Decryption with this method gives:\n`;
  explanation += `   m ≡ c₂ · (hʸ)⁻¹ mod p = ${c2} · ${invHPowY} (mod ${p}) = ${m2}.\n\n`;

  explanation += `4) Comparison of the two methods.\n`;
  explanation += `   Both methods should yield the same clear message.\n`;
  explanation += `   Method 1: m = ${m1}.\n`;
  explanation += `   Method 2: m = ${m2}.\n`;

  if (m1 !== m2) {
    explanation += `   (Warning: the two methods differ — check the parameters.)\n`;
  }

  explanation += `\nSo the clear message is m = ${m1}.`;

  return { m: m1, explanation };
}
