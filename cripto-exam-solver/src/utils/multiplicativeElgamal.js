// src/utils/multiplicativeElgamal.js
import { modInverse, modPow } from "./rsa";

export function solveMultiplicativeElgamal(p, g, h, c1, c2) {
  let explanation = "";

  explanation += `We are working in the multiplicative ElGamal scheme modulo p = ${p}.\n`;
  explanation += `The group is (ℤ_${p}^×, ·, 1), generated by g = ${g}.\n`;
  explanation += `Alice's public key is h = ${h} and Bob sends the ciphertext (c₁, c₂) = (${c1}, ${c2}).\n\n`;

  explanation += `1) Recover Alice's secret key x from h = gˣ.\n`;
  explanation += `   In general this is the discrete logarithm problem, but here p is small,\n`;
  explanation += `   so we can find x by checking successive powers of g modulo p.\n\n`;

  // Find x such that g^x ≡ h (mod p)
  let current = 1;
  let x = -1;
  const powers = [];

  for (let k = 1; k <= p - 1; k++) {
    current = (current * g) % p;
    powers.push({ k, value: current });
    if (current === (h % p + p) % p) {
      x = k;
      break;
    }
  }

  if (x === -1) {
    throw new Error(`Could not find x such that gˣ ≡ h (mod p). Check inputs.`);
  }

  explanation += `   Powers of g modulo p (up to the point we find h):\n`;
  powers.forEach(({ k, value }) => {
    explanation += `   g^${k} ≡ ${value} (mod ${p})\n`;
    if (value === h % p) {
      explanation += `   ⇒ For k = ${k}, g^${k} ≡ h = ${h} (mod ${p}), so the secret key is x = ${k}.\n`;
    }
  });
  explanation += `\n`;

  // Compute c1^x mod p
  const c1PowX = modPow(c1, x, p);
  explanation += `2) Compute c₁ˣ modulo p.\n`;
  explanation += `   c₁ˣ ≡ ${c1}^${x} mod ${p} = ${c1PowX}.\n\n`;

  // Compute inverse of c1^x
  const inv = modInverse(c1PowX, p);
  explanation += `3) Compute the inverse of c₁ˣ modulo p by the extended Euclidean algorithm.\n`;
  explanation += `   Let a = c₁ˣ = ${c1PowX}. We find a⁻¹ such that a·a⁻¹ ≡ 1 (mod ${p}).\n`;
  explanation += `   The result is a⁻¹ ≡ ${inv} (mod ${p}).\n\n`;

  // Recover m
  let m = (c2 * inv) % p;
  if (m < 0) m += p;

  explanation += `4) Recover the clear message m.\n`;
  explanation += `   m ≡ c₂ · (c₁ˣ)⁻¹ mod p = ${c2} · ${inv} mod ${p} = ${m}.\n\n`;
  explanation += `So the clear message is m = ${m}.`;

  return { m, explanation };
}
